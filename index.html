<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mastering Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #1a202c, #2d3748, #4a5568);
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Custom slider styles */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 6px; background: #4a5568; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; margin-top: -5px; width: 16px; height: 16px; background: #a0aec0; border-radius: 50%; border: 2px solid #1a202c;
        }
        input[type=range]:focus::-webkit-slider-thumb {
            background: #cbd5e0; box-shadow: 0 0 5px #6366f1;
        }
        .meter-track {
            background-color: #2d3748; height: 10px; border-radius: 5px; overflow: hidden; width: 100%; border: 1px solid #4a5568;
        }
        .meter-bar {
            background-color: #f59e0b; height: 100%; width: 0%; transition: width 0.05s linear;
        }
        #waveform-container {
            position: relative; height: 100px; background-color: rgba(0,0,0,0.2); border-radius: 0.5rem; cursor: pointer; overflow: hidden;
        }
        #playhead {
            position: absolute; top: 0; bottom: 0; left: 0; width: 2px; background-color: #f87171; /* Red 400 */ pointer-events: none;
        }
        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 34px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4a5568; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(14px); }
        .editable-span { cursor: text; position: relative; }
        
        /* LUFS Modal */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="gradient-bg text-gray-200 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white tracking-tight">Interactive Mastering Engine</h1>
            <p class="text-lg text-gray-400 mt-2">Analyze, get settings, then fine-tune your master in real-time.</p>
        </header>

        <main class="glass-card rounded-2xl shadow-2xl p-6 md:p-8 relative">
            <!-- Upload Section -->
            <div id="upload-section">
                <div class="flex items-center justify-center w-full">
                     <label for="audio-upload" class="flex flex-col items-center justify-center w-full h-64 border-2 border-dashed border-gray-500 rounded-lg cursor-pointer bg-gray-700/50 hover:bg-gray-700/80 transition-colors">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6"><svg class="w-10 h-10 mb-4 text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/></svg><p class="mb-2 text-sm text-gray-400"><span class="font-semibold">Click to upload</span></p><p class="text-xs text-gray-500">WAV, MP3, or FLAC</p></div>
                        <input id="audio-upload" type="file" class="hidden" accept="audio/wav, audio/mpeg, audio/flac, .wav, .mp3, .flac">
                    </label>
                </div>
                <div id="file-info" class="text-center mt-4 text-gray-300 hidden"><p>File: <span id="file-name" class="font-semibold"></span></p></div>
                 <button id="get-instructions-btn" class="w-full mt-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>Analyze and Master</button>
            </div>

            <!-- Result Section -->
            <div id="result-section" class="hidden">
                <div id="loading-spinner" class="text-center"><svg class="animate-spin h-10 w-10 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><p id="loading-text" class="mt-4 text-gray-400">Initializing...</p></div>
                
                <div id="controls-wrapper" class="hidden">
                    <!-- Player Controls -->
                    <div id="player-controls" class="p-4 border-b border-gray-700 mb-6 space-y-4">
                        <div class="flex flex-wrap justify-center gap-4">
                            <button id="preview-original-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">Preview Original</button>
                            <button id="preview-mastered-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">Preview Mastered</button>
                            <button id="check-lufs-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg transition-colors flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg>
                                Check LUFS
                            </button>
                            <button id="download-mastered-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">Download Mastered</button>
                        </div>
                        <div id="waveform-display" class="pt-2">
                             <div id="waveform-container"><canvas id="waveform-canvas" style="width: 100%; height: 100%;"></canvas><div id="playhead"></div></div>
                             <div class="flex justify-between text-xs font-mono text-gray-400 mt-1"><span id="current-time">0:00</span><span id="total-time">0:00</span></div>
                        </div>
                    </div>
                    
                    <!-- Effects Chain UI -->
                    <div id="effects-chain-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
                        <!-- Corrective EQ -->
                        <div class="bg-gray-800/50 p-4 rounded-lg space-y-3">
                            <h5 class="font-bold text-indigo-400">Corrective EQ</h5>
                            <div class="space-y-2 pt-1">
                                <div class="flex justify-between items-center"><h6 class="text-xs font-bold uppercase text-gray-400">Band 1 (Low-Mid)</h6><label class="switch"><input type="checkbox" id="ceq-b1-enable"><span class="slider"></span></label></div>
                                <div id="ceq-b1-controls" class="space-y-2 transition-opacity duration-300">
                                    <div class="flex justify-between items-center text-sm"><label>Frequency</label><span id="ceq-b1-freq-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">350 Hz</span></div><input type="range" id="ceq-b1-freq" min="200" max="800" step="5" class="w-full">
                                    <div class="flex justify-between items-center text-sm"><label>Gain</label><span id="ceq-b1-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">-2.0 dB</span></div><input type="range" id="ceq-b1-gain" min="-12" max="0" step="0.1" class="w-full">
                                    <div class="flex justify-between items-center text-sm"><label>Q</label><span id="ceq-b1-q-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">3.5</span></div><input type="range" id="ceq-b1-q" min="1" max="10" step="0.1" class="w-full">
                                </div>
                            </div>
                            <div class="space-y-2 pt-2 border-t border-gray-700">
                                <div class="flex justify-between items-center"><h6 class="text-xs font-bold uppercase text-gray-400">Band 2 (High-Mid)</h6><label class="switch"><input type="checkbox" id="ceq-b2-enable"><span class="slider"></span></label></div>
                                <div id="ceq-b2-controls" class="space-y-2 transition-opacity duration-300">
                                    <div class="flex justify-between items-center text-sm"><label>Frequency</label><span id="ceq-b2-freq-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">4500 Hz</span></div><input type="range" id="ceq-b2-freq" min="2000" max="7000" step="50" class="w-full">
                                    <div class="flex justify-between items-center text-sm"><label>Gain</label><span id="ceq-b2-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">-1.5 dB</span></div><input type="range" id="ceq-b2-gain" min="-12" max="0" step="0.1" class="w-full">
                                    <div class="flex justify-between items-center text-sm"><label>Q</label><span id="ceq-b2-q-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">4.0</span></div><input type="range" id="ceq-b2-q" min="1" max="10" step="0.1" class="w-full">
                                </div>
                            </div>
                        </div>
                        <!-- Compressor -->
                        <div class="bg-gray-800/50 p-4 rounded-lg space-y-3">
                            <p class="text-xs text-center text-gray-400 italic -mt-1 mb-2">Tip: Shoot for no more than 2 dB of gain reduction.</p>
                            <h5 class="font-bold text-indigo-400">Compressor</h5>
                            <div class="space-y-2">
                                <div class="flex justify-between items-center text-sm"><label>Threshold</label><span id="comp-threshold-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">-18.0 dB</span></div><input type="range" id="comp-threshold" min="-40" max="0" step="0.5" class="w-full">
                                <div class="flex justify-between items-center text-sm"><label>Ratio</label><span id="comp-ratio-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">2.0 : 1</span></div><input type="range" id="comp-ratio" min="1" max="10" step="0.1" class="w-full">
                                <div class="flex justify-between items-center text-sm"><label>Attack</label><span id="comp-attack-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">25 ms</span></div><input type="range" id="comp-attack" min="1" max="100" step="1" class="w-full">
                                <div class="flex justify-between items-center text-sm"><label>Release</label><span id="comp-release-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">100 ms</span></div><input type="range" id="comp-release" min="10" max="500" step="5" class="w-full">
                            </div>
                            <div class="pt-2"><div class="text-sm mb-1 text-gray-400">Gain Reduction</div><div class="flex items-center gap-2"><div class="meter-track flex-grow"><div id="comp-gr-meter" class="meter-bar"></div></div><span id="comp-gr-val" class="w-16 text-right font-mono text-sm text-amber-400">-0.0 dB</span></div></div>
                        </div>
                        <!-- Tonal EQ -->
                        <div class="bg-gray-800/50 p-4 rounded-lg space-y-3">
                            <p class="text-xs text-center text-gray-400 italic -mt-1 mb-2">Tip: Add no more than 1dB of Gain (above the Mastering Engine suggestion) to the Low Shelf for added low end weight.</p>
                            <h5 class="font-bold text-indigo-400">Tonal EQ</h5>
                            <div id="tonal-eq-controls" class="space-y-3">
                                <div class="space-y-2"><h6 class="text-xs font-bold uppercase text-gray-400">Low Shelf (@ 120Hz)</h6><div class="flex justify-between items-center text-sm"><label>Gain</label><span id="teq-low-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">0.0 dB</span></div><input type="range" id="teq-low-gain" min="-6" max="6" step="0.1" class="w-full"></div>
                                <div class="space-y-2"><h6 class="text-xs font-bold uppercase text-gray-400">Mid Peak</h6><div class="flex justify-between items-center text-sm"><label>Frequency</label><span id="teq-mid-freq-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">3500 Hz</span></div><input type="range" id="teq-mid-freq" min="2000" max="5000" step="50" class="w-full"><div class="flex justify-between items-center text-sm"><label>Gain</label><span id="teq-mid-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">0.0 dB</span></div><input type="range" id="teq-mid-gain" min="-6" max="6" step="0.1" class="w-full"><div class="flex justify-between items-center text-sm"><label>Q</label><span id="teq-mid-q-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">1.5</span></div><input type="range" id="teq-mid-q" min="0.5" max="5" step="0.1" class="w-full"></div>
                                <div class="space-y-2"><h6 class="text-xs font-bold uppercase text-gray-400">High Shelf (@ 12kHz)</h6><div class="flex justify-between items-center text-sm"><label>Gain</label><span id="teq-high-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">0.0 dB</span></div><input type="range" id="teq-high-gain" min="-6" max="6" step="0.1" class="w-full"></div>
                            </div>
                            <div id="hpf-display" class="text-xs text-center text-gray-500 pt-2"></div>
                        </div>
                        <!-- Loudness Maximizer -->
                        <div class="bg-gray-800/50 p-4 rounded-lg space-y-3">
                             <p class="text-xs text-center text-gray-400 italic -mt-1 mb-2">Tip: No more than 1 dB of Gain Reduction.</p>
                            <h5 class="font-bold text-indigo-400">Loudness Maximizer</h5>
                            <div class="space-y-2"><div class="flex justify-between items-center text-sm"><label>Makeup Gain</label><span id="limiter-gain-val" class="editable-span font-mono bg-gray-900 px-2 py-0.5 rounded">3.5 dB</span></div><input type="range" id="limiter-gain" min="0" max="12" step="0.1" class="w-full"></div>
                            <div class="pt-2 mt-auto"><div class="text-sm mb-1 text-gray-400">Gain Reduction</div><div class="flex items-center gap-2"><div class="meter-track flex-grow"><div id="limiter-gr-meter" class="meter-bar"></div></div><span id="limiter-gr-val" class="w-16 text-right font-mono text-sm text-amber-400">-0.0 dB</span></div></div>
                        </div>
                    </div>
                </div>

                <div id="donation-section" class="hidden text-center mt-8 pt-6 border-t border-gray-700"><p class="text-gray-400 mb-2">If you enjoy this service, please consider donating.</p><a href="https://coff.ee/iceestudios" target="_blank" rel="noopener noreferrer" class="inline-block bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg transition-colors">Buy me a coffee! â˜•</a></div>
                <button id="reset-btn" class="w-full mt-8 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 hidden">Start Over</button>
            </div>
        </main>
        
        <!-- LUFS Result Modal -->
        <div id="lufs-modal" class="fixed inset-0 modal-overlay hidden flex items-center justify-center z-50">
            <div class="glass-card p-8 rounded-2xl shadow-2xl max-w-sm w-full text-center border border-gray-600">
                <h3 class="text-2xl font-bold text-white mb-2">Loudness Analysis</h3>
                <div class="py-6">
                    <p class="text-gray-400 text-sm uppercase tracking-wider">Integrated LUFS</p>
                    <div id="lufs-display-value" class="text-5xl font-bold text-purple-400 mt-2">-14.0</div>
                    <p class="text-xs text-gray-500 mt-2">(EBU R128 Standard)</p>
                </div>
                <div class="space-y-3">
                    <p id="lufs-target-msg" class="text-sm text-gray-300"></p>
                    <button id="close-lufs-modal" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Prevent Browser Default Drag/Drop ---
        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', e => e.preventDefault());

        // --- UI Elements ---
        const ui = {
            uploadSection: document.getElementById('upload-section'), resultSection: document.getElementById('result-section'), audioUpload: document.getElementById('audio-upload'), getInstructionsBtn: document.getElementById('get-instructions-btn'), fileInfo: document.getElementById('file-info'), fileNameEl: document.getElementById('file-name'), loadingSpinner: document.getElementById('loading-spinner'), loadingText: document.getElementById('loading-text'), resetBtn: document.getElementById('reset-btn'), playerControls: document.getElementById('player-controls'), previewOriginalBtn: document.getElementById('preview-original-btn'), previewMasteredBtn: document.getElementById('preview-mastered-btn'), downloadMasteredBtn: document.getElementById('download-mastered-btn'), checkLufsBtn: document.getElementById('check-lufs-btn'), donationSection: document.getElementById('donation-section'), controlsWrapper: document.getElementById('controls-wrapper'),
            waveformContainer: document.getElementById('waveform-container'), waveformCanvas: document.getElementById('waveform-canvas'), playhead: document.getElementById('playhead'), currentTime: document.getElementById('current-time'), totalTime: document.getElementById('total-time'),
            lufsModal: document.getElementById('lufs-modal'), lufsValue: document.getElementById('lufs-display-value'), lufsMsg: document.getElementById('lufs-target-msg'), closeLufsModal: document.getElementById('close-lufs-modal'),
            ceq: { 
                b1: { enable: document.getElementById('ceq-b1-enable'), controls: document.getElementById('ceq-b1-controls'), freqSlider: document.getElementById('ceq-b1-freq'), freqVal: document.getElementById('ceq-b1-freq-val'), gainSlider: document.getElementById('ceq-b1-gain'), gainVal: document.getElementById('ceq-b1-gain-val'), qSlider: document.getElementById('ceq-b1-q'), qVal: document.getElementById('ceq-b1-q-val') },
                b2: { enable: document.getElementById('ceq-b2-enable'), controls: document.getElementById('ceq-b2-controls'), freqSlider: document.getElementById('ceq-b2-freq'), freqVal: document.getElementById('ceq-b2-freq-val'), gainSlider: document.getElementById('ceq-b2-gain'), gainVal: document.getElementById('ceq-b2-gain-val'), qSlider: document.getElementById('ceq-b2-q'), qVal: document.getElementById('ceq-b2-q-val') }
            },
            comp: { thresholdSlider: document.getElementById('comp-threshold'), thresholdVal: document.getElementById('comp-threshold-val'), ratioSlider: document.getElementById('comp-ratio'), ratioVal: document.getElementById('comp-ratio-val'), attackSlider: document.getElementById('comp-attack'), attackVal: document.getElementById('comp-attack-val'), releaseSlider: document.getElementById('comp-release'), releaseVal: document.getElementById('comp-release-val'), grMeter: document.getElementById('comp-gr-meter'), grVal: document.getElementById('comp-gr-val') },
            teq: { lowGainSlider: document.getElementById('teq-low-gain'), lowGainVal: document.getElementById('teq-low-gain-val'), midFreqSlider: document.getElementById('teq-mid-freq'), midFreqVal: document.getElementById('teq-mid-freq-val'), midGainSlider: document.getElementById('teq-mid-gain'), midGainVal: document.getElementById('teq-mid-gain-val'), midQSlider: document.getElementById('teq-mid-q'), midQVal: document.getElementById('teq-mid-q-val'), highGainSlider: document.getElementById('teq-high-gain'), highGainVal: document.getElementById('teq-high-gain-val'), hpfDisplay: document.getElementById('hpf-display') },
            limiter: { gainSlider: document.getElementById('limiter-gain'), gainVal: document.getElementById('limiter-gain-val'), grMeter: document.getElementById('limiter-gr-meter'), grVal: document.getElementById('limiter-gr-val') }
        };

        // --- State Variables ---
        let uploadedFile = null, audioBuffer = null, masteringSettings = null, audioContext = null, currentSource = null, lastPlayedType = null, isPlaying = false, activeAudioNodes = null, isMetering = false, animationFrameId = null;
        let playbackStartTime = 0, startOffset = 0;
        
        // --- AUDIO ANALYSIS ---
        const analyzeAudio = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const tempAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const buffer = await tempAudioContext.decodeAudioData(e.target.result);
                        tempAudioContext.close();
                        audioBuffer = buffer;
                        const offlineContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
                        const source = offlineContext.createBufferSource();
                        source.buffer = buffer;
                        const analyser = offlineContext.createAnalyser();
                        analyser.fftSize = 8192;
                        const rmsValues = [], freqData = new Uint8Array(analyser.frequencyBinCount), avgFreqData = new Float32Array(analyser.frequencyBinCount).fill(0);
                        let processCount = 0;
                        const scriptProcessor = offlineContext.createScriptProcessor(4096, buffer.numberOfChannels, 1);
                        scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                            analyser.getByteFrequencyData(freqData);
                            for (let i = 0; i < analyser.frequencyBinCount; i++) avgFreqData[i] += freqData[i];
                            processCount++;
                            const inputBuffer = audioProcessingEvent.inputBuffer;
                            for (let channel = 0; channel < inputBuffer.numberOfChannels; channel++) {
                                const channelData = inputBuffer.getChannelData(channel);
                                let sumOfSquares = 0;
                                for (let i = 0; i < channelData.length; i++) sumOfSquares += channelData[i] * channelData[i];
                                const rms = Math.sqrt(sumOfSquares / channelData.length);
                                if (rms > 0) rmsValues.push(20 * Math.log10(rms));
                            }
                        };
                        source.connect(analyser);
                        analyser.connect(scriptProcessor);
                        scriptProcessor.connect(offlineContext.destination);
                        source.start(0);
                        offlineContext.startRendering().then(() => {
                            const sortedRms = rmsValues.filter(v => isFinite(v)).sort((a, b) => a - b);
                            const loudnessRange = sortedRms.length > 10 ? sortedRms[Math.floor(sortedRms.length * 0.95)] - sortedRms[Math.floor(sortedRms.length * 0.10)] : 8;
                            let peak = 0;
                            for (let i = 0; i < buffer.numberOfChannels; i++) {
                                const pcmData = buffer.getChannelData(i);
                                for (let j = 0; j < pcmData.length; j++) {
                                    const sample = Math.abs(pcmData[j]);
                                    if (sample > peak) peak = sample;
                                }
                            }
                            const peakDb = peak > 0 ? 20 * Math.log10(peak) : -144;
                            if (processCount > 0) for (let i = 0; i < analyser.frequencyBinCount; i++) avgFreqData[i] /= processCount;
                            const getAvgEnergy = (startFreq, endFreq) => {
                                const startIndex = Math.round(startFreq / buffer.sampleRate * analyser.fftSize), endIndex = Math.round(endFreq / buffer.sampleRate * analyser.fftSize);
                                let sum = 0;
                                for (let i = startIndex; i <= endIndex; i++) sum += avgFreqData[i];
                                return sum / (endIndex - startIndex + 1);
                            };
                            const findPeakInRange = (startFreq, endFreq) => {
                                let maxVal = -1, peakFreq = -1;
                                const startIndex = Math.round(startFreq / buffer.sampleRate * analyser.fftSize), endIndex = Math.round(endFreq / buffer.sampleRate * analyser.fftSize);
                                for (let i = startIndex; i <= endIndex; i++) {
                                    if (avgFreqData[i] > maxVal) {
                                        maxVal = avgFreqData[i];
                                        peakFreq = Math.round(i * buffer.sampleRate / analyser.fftSize);
                                    }
                                }
                                return peakFreq;
                            };
                            const analysisResults = {
                                peakDb, loudnessRange,
                                corrective: {
                                    lowMidEnergy: getAvgEnergy(200, 500),
                                    presenceEnergy: getAvgEnergy(3000, 6000),
                                    muddyFreq: findPeakInRange(200, 500),
                                    harshFreq: findPeakInRange(3000, 6000)
                                },
                                tonal: {
                                    subBassEnergy: getAvgEnergy(20, 60),
                                    lowShelfEnergy: getAvgEnergy(60, 200),
                                    midRangeEnergy: getAvgEnergy(500, 2000),
                                    highShelfEnergy: getAvgEnergy(10000, 20000),
                                    midPeakFreq: findPeakInRange(2000, 5000)
                                }
                            };
                            resolve(analysisResults);
                        }).catch(reject);
                    } catch (error) { reject(new Error("Could not decode audio file. It may be corrupt or an unsupported format.")); }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        };

        // --- SETTINGS GENERATOR ---
        const generateMasteringSettings = (analysis) => {
            const { corrective, tonal, peakDb, loudnessRange } = analysis;
            const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

            // Corrective EQ Settings
            const correctiveEQ = {
                band1: { active: corrective.lowMidEnergy > 110 && corrective.muddyFreq > 0, frequency: corrective.muddyFreq || 350, gain: -2.0, q: 3.5 },
                band2: { active: corrective.presenceEnergy > 100 && corrective.harshFreq > 0, frequency: corrective.harshFreq || 4500, gain: -1.5, q: 4.0 }
            };

            // Compressor Settings
            const compressor = { 
                threshold: -18.0, 
                ratio: loudnessRange > 10 ? 2.0 : 1.5, 
                attack: peakDb > -3 ? 50 : 25, 
                release: (peakDb > -3 ? 50 : 25) * 4 
            };

            // --- REFINED Tonal EQ Logic ---
            const midEnergy = tonal.midRangeEnergy > 0 ? tonal.midRangeEnergy : 1;
            
            const idealLowToMidRatio = 1.25;
            const idealHighToMidRatio = 0.6;
            
            const actualLowToMidRatio = tonal.lowShelfEnergy / midEnergy;
            const actualHighToMidRatio = tonal.highShelfEnergy / midEnergy;

            // Calculate gain with more subtle scaling factors
            const lowGain = (idealLowToMidRatio - actualLowToMidRatio) * 1.5; // Reduced from 2.5
            const highGain = (idealHighToMidRatio - actualHighToMidRatio) * 2.0; // Reduced from 3.5

            const tonalEQ = {
                highPass: { active: tonal.subBassEnergy > 95, frequency: 30 },
                lowShelf: { 
                    frequency: 120, 
                    gain: clamp(lowGain, -2.0, 2.0) // Clamped to a more gentle +/- 2.0dB
                },
                midPeak: { 
                    frequency: tonal.midPeakFreq > 0 ? tonal.midPeakFreq : 3500, 
                    gain: tonal.midRangeEnergy < 75 ? clamp(((75 - tonal.midRangeEnergy) / 25), 0, 1.5) : 0, // Slightly less sensitive boost
                    q: 1.5 
                },
                highShelf: { 
                    frequency: 12000, 
                    gain: clamp(highGain, -2.0, 2.0) // Clamped to a more gentle +/- 2.0dB
                }
            };
            // --- End of Refined Logic ---

            // Limiter Settings
            const limiter = { threshold: -1.0, makeupGain: loudnessRange > 12 ? 5.0 : (loudnessRange > 8 ? 3.5 : 2.0) };
            
            return { correctiveEQ, compressor, tonalEQ, limiter };
        };

        // --- UI & INTERACTIVITY ---
        function populateUI(settings) {
            const { ceq, comp, teq, limiter } = ui;
            const { correctiveEQ, compressor, tonalEQ, limiter: limiterSettings } = settings;
            const setupBandUI = (bandData, bandUI) => {
                bandUI.enable.checked = bandData.active;
                bandUI.freqSlider.value = bandData.frequency;
                bandUI.freqVal.textContent = `${bandData.frequency} Hz`;
                bandUI.gainSlider.value = bandData.gain;
                bandUI.gainVal.textContent = `${bandData.gain.toFixed(1)} dB`;
                bandUI.qSlider.value = bandData.q;
                bandUI.qVal.textContent = bandData.q.toFixed(1);
                bandUI.controls.style.opacity = bandData.active ? '1' : '0.5';
                bandUI.controls.style.pointerEvents = bandData.active ? 'auto' : 'none';
            };
            setupBandUI(correctiveEQ.band1, ceq.b1);
            setupBandUI(correctiveEQ.band2, ceq.b2);
            comp.thresholdSlider.value = compressor.threshold;
            comp.thresholdVal.textContent = `${compressor.threshold.toFixed(1)} dB`;
            comp.ratioSlider.value = compressor.ratio;
            comp.ratioVal.textContent = `${compressor.ratio.toFixed(1)} : 1`;
            comp.attackSlider.value = compressor.attack;
            comp.attackVal.textContent = `${compressor.attack.toFixed(0)} ms`;
            comp.releaseSlider.value = compressor.release;
            comp.releaseVal.textContent = `${compressor.release.toFixed(0)} ms`;
            teq.hpfDisplay.textContent = tonalEQ.highPass.active ? `High-Pass Filter @ ${tonalEQ.highPass.frequency}Hz` : '';
            teq.lowGainSlider.value = tonalEQ.lowShelf.gain;
            teq.lowGainVal.textContent = `${tonalEQ.lowShelf.gain.toFixed(1)} dB`;
            teq.midFreqSlider.value = tonalEQ.midPeak.frequency;
            teq.midFreqVal.textContent = `${tonalEQ.midPeak.frequency} Hz`;
            teq.midGainSlider.value = tonalEQ.midPeak.gain;
            teq.midGainVal.textContent = `${tonalEQ.midPeak.gain.toFixed(1)} dB`;
            teq.midQSlider.value = tonalEQ.midPeak.q;
            teq.midQVal.textContent = `${tonalEQ.midPeak.q.toFixed(1)}`;
            teq.highGainSlider.value = tonalEQ.highShelf.gain;
            teq.highGainVal.textContent = `${tonalEQ.highShelf.gain.toFixed(1)} dB`;
            limiter.gainSlider.value = limiterSettings.makeupGain;
            limiter.gainVal.textContent = `+${limiterSettings.makeupGain.toFixed(1)} dB`;
        }
        
        function makeSpanEditable(span, slider, config) {
            span.addEventListener('click', () => {
                let isHandled = false;
                const originalValue = parseFloat(slider.value);
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'bg-slate-900 text-white text-center font-mono focus:outline-none focus:ring-2 focus:ring-indigo-500 rounded p-0 m-0';
                input.style.width = `${span.offsetWidth + 2}px`;
                input.style.height = `${span.offsetHeight}px`;
                input.value = parseFloat(originalValue).toFixed(config.step.toString().includes('.') ? 1 : 0);
                input.min = config.min;
                input.max = config.max;
                input.step = config.step;
                
                span.style.display = 'none';
                span.parentElement.appendChild(input);
                input.focus();
                input.select();

                const finishEditing = (commit) => {
                    if (isHandled) return;
                    isHandled = true;

                    if (commit) {
                        let newValue = parseFloat(input.value);
                        if (isNaN(newValue)) {
                            newValue = originalValue;
                        } else {
                            newValue = Math.max(config.min, Math.min(config.max, newValue));
                        }
                        config.update(newValue);
                    }
                    
                    if (input.parentElement) {
                        input.remove();
                    }
                    span.style.display = '';
                };
                
                input.addEventListener('blur', () => finishEditing(true));
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEditing(true); // Commit
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finishEditing(false); // Cancel
                    }
                });
            });
        }

        function setupAllListeners() {
            const setParam = (node, param, value) => { if(node && audioContext) node[param].setTargetAtTime(value, audioContext.currentTime, 0.01) };
            const setupCeqBandListeners = (bandKey, bandUI) => {
                const band = masteringSettings.correctiveEQ[bandKey];
                bandUI.enable.addEventListener('change', e => { const isActive = e.target.checked; band.active = isActive; bandUI.controls.style.opacity = isActive ? '1' : '0.5'; bandUI.controls.style.pointerEvents = isActive ? 'auto' : 'none'; setParam(activeAudioNodes?.ceq?.[bandKey], 'gain', isActive ? band.gain : 0); });
                const updateFreq = (val) => { band.frequency = val; bandUI.freqVal.textContent = `${val} Hz`; bandUI.freqSlider.value = val; setParam(activeAudioNodes?.ceq?.[bandKey], 'frequency', val); };
                const updateGain = (val) => { band.gain = val; bandUI.gainVal.textContent = `${val.toFixed(1)} dB`; bandUI.gainSlider.value = val; if (band.active) setParam(activeAudioNodes?.ceq?.[bandKey], 'gain', val); };
                const updateQ = (val) => { band.q = val; bandUI.qVal.textContent = val.toFixed(1); bandUI.qSlider.value = val; setParam(activeAudioNodes?.ceq?.[bandKey], 'Q', val); };
                bandUI.freqSlider.addEventListener('input', e => updateFreq(parseFloat(e.target.value)));
                bandUI.gainSlider.addEventListener('input', e => updateGain(parseFloat(e.target.value)));
                bandUI.qSlider.addEventListener('input', e => updateQ(parseFloat(e.target.value)));
                makeSpanEditable(bandUI.freqVal, bandUI.freqSlider, { min: parseFloat(bandUI.freqSlider.min), max: parseFloat(bandUI.freqSlider.max), step: parseFloat(bandUI.freqSlider.step), update: updateFreq });
                makeSpanEditable(bandUI.gainVal, bandUI.gainSlider, { min: parseFloat(bandUI.gainSlider.min), max: parseFloat(bandUI.gainSlider.max), step: parseFloat(bandUI.gainSlider.step), update: updateGain });
                makeSpanEditable(bandUI.qVal, bandUI.qSlider, { min: parseFloat(bandUI.qSlider.min), max: parseFloat(bandUI.qSlider.max), step: parseFloat(bandUI.qSlider.step), update: updateQ });
            };
            setupCeqBandListeners('band1', ui.ceq.b1);
            setupCeqBandListeners('band2', ui.ceq.b2);
            const updateCompThreshold = (val) => { masteringSettings.compressor.threshold = val; ui.comp.thresholdVal.textContent = `${val.toFixed(1)} dB`; ui.comp.thresholdSlider.value = val; setParam(activeAudioNodes?.compressor, 'threshold', val); };
            const updateCompRatio = (val) => { masteringSettings.compressor.ratio = val; ui.comp.ratioVal.textContent = `${val.toFixed(1)} : 1`; ui.comp.ratioSlider.value = val; setParam(activeAudioNodes?.compressor, 'ratio', val); };
            const updateCompAttack = (val) => { masteringSettings.compressor.attack = val; ui.comp.attackVal.textContent = `${val.toFixed(0)} ms`; ui.comp.attackSlider.value = val; setParam(activeAudioNodes?.compressor, 'attack', val / 1000); };
            const updateCompRelease = (val) => { masteringSettings.compressor.release = val; ui.comp.releaseVal.textContent = `${val.toFixed(0)} ms`; ui.comp.releaseSlider.value = val; setParam(activeAudioNodes?.compressor, 'release', val / 1000); };
            ui.comp.thresholdSlider.addEventListener('input', e => updateCompThreshold(parseFloat(e.target.value)));
            ui.comp.ratioSlider.addEventListener('input', e => updateCompRatio(parseFloat(e.target.value)));
            ui.comp.attackSlider.addEventListener('input', e => updateCompAttack(parseFloat(e.target.value)));
            ui.comp.releaseSlider.addEventListener('input', e => updateCompRelease(parseFloat(e.target.value)));
            makeSpanEditable(ui.comp.thresholdVal, ui.comp.thresholdSlider, { min: -40, max: 0, step: 0.1, update: updateCompThreshold });
            makeSpanEditable(ui.comp.ratioVal, ui.comp.ratioSlider, { min: 1, max: 10, step: 0.1, update: updateCompRatio });
            makeSpanEditable(ui.comp.attackVal, ui.comp.attackSlider, { min: 1, max: 100, step: 1, update: updateCompAttack });
            makeSpanEditable(ui.comp.releaseVal, ui.comp.releaseSlider, { min: 10, max: 500, step: 1, update: updateCompRelease });
            const updateTeqLowGain = (val) => { masteringSettings.tonalEQ.lowShelf.gain = val; ui.teq.lowGainVal.textContent = `${val.toFixed(1)} dB`; ui.teq.lowGainSlider.value = val; setParam(activeAudioNodes?.teq?.lowShelf, 'gain', val); };
            const updateTeqMidFreq = (val) => { masteringSettings.tonalEQ.midPeak.frequency = val; ui.teq.midFreqVal.textContent = `${val} Hz`; ui.teq.midFreqSlider.value = val; setParam(activeAudioNodes?.teq?.midPeak, 'frequency', val); };
            const updateTeqMidGain = (val) => { masteringSettings.tonalEQ.midPeak.gain = val; ui.teq.midGainVal.textContent = `${val.toFixed(1)} dB`; ui.teq.midGainSlider.value = val; setParam(activeAudioNodes?.teq?.midPeak, 'gain', val); };
            const updateTeqMidQ = (val) => { masteringSettings.tonalEQ.midPeak.q = val; ui.teq.midQVal.textContent = `${val.toFixed(1)}`; ui.teq.midQSlider.value = val; setParam(activeAudioNodes?.teq?.midPeak, 'Q', val); };
            const updateTeqHighGain = (val) => { masteringSettings.tonalEQ.highShelf.gain = val; ui.teq.highGainVal.textContent = `${val.toFixed(1)} dB`; ui.teq.highGainSlider.value = val; setParam(activeAudioNodes?.teq?.highShelf, 'gain', val); };
            ui.teq.lowGainSlider.addEventListener('input', e => updateTeqLowGain(parseFloat(e.target.value)));
            ui.teq.midFreqSlider.addEventListener('input', e => updateTeqMidFreq(parseFloat(e.target.value)));
            ui.teq.midGainSlider.addEventListener('input', e => updateTeqMidGain(parseFloat(e.target.value)));
            ui.teq.midQSlider.addEventListener('input', e => updateTeqMidQ(parseFloat(e.target.value)));
            ui.teq.highGainSlider.addEventListener('input', e => updateTeqHighGain(parseFloat(e.target.value)));
            makeSpanEditable(ui.teq.lowGainVal, ui.teq.lowGainSlider, { min: -6, max: 6, step: 0.1, update: updateTeqLowGain });
            makeSpanEditable(ui.teq.midFreqVal, ui.teq.midFreqSlider, { min: 2000, max: 5000, step: 50, update: updateTeqMidFreq });
            makeSpanEditable(ui.teq.midGainVal, ui.teq.midGainSlider, { min: -6, max: 6, step: 0.1, update: updateTeqMidGain });
            makeSpanEditable(ui.teq.midQVal, ui.teq.midQSlider, { min: 0.5, max: 5, step: 0.1, update: updateTeqMidQ });
            makeSpanEditable(ui.teq.highGainVal, ui.teq.highGainSlider, { min: -6, max: 6, step: 0.1, update: updateTeqHighGain });
            const updateLimiterGain = (val) => { masteringSettings.limiter.makeupGain = val; ui.limiter.gainVal.textContent = `+${val.toFixed(1)} dB`; ui.limiter.gainSlider.value = val; setParam(activeAudioNodes?.limiterGain, 'gain', Math.pow(10, val / 20)); };
            ui.limiter.gainSlider.addEventListener('input', e => updateLimiterGain(parseFloat(e.target.value)));
            makeSpanEditable(ui.limiter.gainVal, ui.limiter.gainSlider, { min: 0, max: 12, step: 0.1, update: updateLimiterGain });
        }
        
        function startMeters() { if (isMetering || !isPlaying || !activeAudioNodes) return; isMetering = true; const maxReduction = 24; function meterLoop() { if (!isMetering) { ui.comp.grMeter.style.width = '0%'; ui.limiter.grMeter.style.width = '0%'; ui.comp.grVal.textContent = '-0.0 dB'; ui.limiter.grVal.textContent = '-0.0 dB'; return; } const compRed = activeAudioNodes.compressor ? activeAudioNodes.compressor.reduction : 0; const limRed = activeAudioNodes.limiter ? activeAudioNodes.limiter.reduction : 0; ui.comp.grMeter.style.width = `${(Math.abs(compRed) / maxReduction) * 100}%`; ui.limiter.grMeter.style.width = `${(Math.abs(limRed) / maxReduction) * 100}%`; ui.comp.grVal.textContent = `${compRed.toFixed(1)} dB`; ui.limiter.grVal.textContent = `${limRed.toFixed(1)} dB`; requestAnimationFrame(meterLoop); } meterLoop(); }
        
        // --- AUDIO PROCESSING CHAIN ---
        function applyMasteringChain(context, sourceNode, settings) { let lastNode = sourceNode; const nodes = { ceq: {}, teq: {} }; const now = context.currentTime; const ceqB1 = context.createBiquadFilter(); ceqB1.type = 'peaking'; ceqB1.frequency.setValueAtTime(settings.correctiveEQ.band1.frequency, now); ceqB1.Q.setValueAtTime(settings.correctiveEQ.band1.q, now); ceqB1.gain.setValueAtTime(settings.correctiveEQ.band1.active ? settings.correctiveEQ.band1.gain : 0, now); lastNode.connect(ceqB1); lastNode = ceqB1; nodes.ceq.band1 = ceqB1; const ceqB2 = context.createBiquadFilter(); ceqB2.type = 'peaking'; ceqB2.frequency.setValueAtTime(settings.correctiveEQ.band2.frequency, now); ceqB2.Q.setValueAtTime(settings.correctiveEQ.band2.q, now); ceqB2.gain.setValueAtTime(settings.correctiveEQ.band2.active ? settings.correctiveEQ.band2.gain : 0, now); lastNode.connect(ceqB2); lastNode = ceqB2; nodes.ceq.band2 = ceqB2; const comp = settings.compressor; const compressor = context.createDynamicsCompressor(); compressor.threshold.setValueAtTime(comp.threshold, now); compressor.ratio.setValueAtTime(comp.ratio, now); compressor.attack.setValueAtTime(comp.attack / 1000, now); compressor.release.setValueAtTime(comp.release / 1000, now); compressor.knee.setValueAtTime(5, now); lastNode.connect(compressor); lastNode = compressor; nodes.compressor = compressor; const teq = settings.tonalEQ; if (teq.highPass.active) { const hpf = context.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.setValueAtTime(teq.highPass.frequency, now); lastNode.connect(hpf); lastNode = hpf; nodes.teq.highPass = hpf; } const lowShelf = context.createBiquadFilter(); lowShelf.type = 'lowshelf'; lowShelf.frequency.setValueAtTime(teq.lowShelf.frequency, now); lowShelf.gain.setValueAtTime(teq.lowShelf.gain, now); lastNode.connect(lowShelf); lastNode = lowShelf; nodes.teq.lowShelf = lowShelf; const midPeak = context.createBiquadFilter(); midPeak.type = 'peaking'; midPeak.frequency.setValueAtTime(teq.midPeak.frequency, now); midPeak.gain.setValueAtTime(teq.midPeak.gain, now); midPeak.Q.setValueAtTime(teq.midPeak.q, now); lastNode.connect(midPeak); lastNode = midPeak; nodes.teq.midPeak = midPeak; const highShelf = context.createBiquadFilter(); highShelf.type = 'highshelf'; highShelf.frequency.setValueAtTime(teq.highShelf.frequency, now); highShelf.gain.setValueAtTime(teq.highShelf.gain, now); lastNode.connect(highShelf); lastNode = highShelf; nodes.teq.highShelf = highShelf; const lim = settings.limiter; const makeupGainNode = context.createGain(); makeupGainNode.gain.setValueAtTime(Math.pow(10, lim.makeupGain / 20), now); lastNode.connect(makeupGainNode); lastNode = makeupGainNode; nodes.limiterGain = makeupGainNode; const limiterNode = context.createDynamicsCompressor(); limiterNode.threshold.setValueAtTime(lim.threshold, now); limiterNode.knee.setValueAtTime(0, now); limiterNode.ratio.setValueAtTime(20, now); limiterNode.attack.setValueAtTime(0.001, now); limiterNode.release.setValueAtTime(0.080, now); lastNode.connect(limiterNode); lastNode = limiterNode; nodes.limiter = limiterNode; return { finalNode: lastNode, nodes }; }

        // --- Playback and Export ---
        function updatePlayButtonStates() { if (isPlaying) { if (lastPlayedType === 'original') { ui.previewOriginalBtn.textContent = 'Pause'; ui.previewMasteredBtn.textContent = 'Preview Mastered'; } else { ui.previewMasteredBtn.textContent = 'Pause'; ui.previewOriginalBtn.textContent = 'Preview Original'; } } else { ui.previewOriginalBtn.textContent = 'Preview Original'; ui.previewMasteredBtn.textContent = 'Preview Mastered'; } }
        function stopPlayback(isPausing = false) { if(currentSource) try { currentSource.stop(0); } catch(e){} cancelAnimationFrame(animationFrameId); if (!isPausing) { startOffset = 0; ui.playhead.style.left = '0%'; ui.currentTime.textContent = formatTime(0); } isPlaying = false; isMetering = false; updatePlayButtonStates(); }
        function play(offset = 0, type) { if (audioContext && audioContext.state !== 'closed') { audioContext.close(); } audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: audioBuffer.sampleRate }); if (audioContext.state === 'suspended') audioContext.resume(); const source = audioContext.createBufferSource(); source.buffer = audioBuffer; currentSource = source; let lastNode = source; activeAudioNodes = null; lastPlayedType = type; if (type === 'mastered' && masteringSettings) { try { const chain = applyMasteringChain(audioContext, source, masteringSettings); lastNode = chain.finalNode; activeAudioNodes = chain.nodes; } catch (e) { console.error("Error applying mastering chain:", e); lastNode = source; } } lastNode.connect(audioContext.destination); source.start(0, offset); isPlaying = true; startOffset = offset; playbackStartTime = audioContext.currentTime; updatePlayButtonStates(); if (type === 'mastered') startMeters(); updatePlayhead(); }
        function togglePlayback(type) { if (!audioBuffer) return; if (isPlaying && lastPlayedType !== type) { stopPlayback(true); play(startOffset, type); return; } if (isPlaying) { if(audioContext) { const elapsed = audioContext.currentTime - playbackStartTime; startOffset += elapsed; audioContext.suspend(); } isPlaying = false; isMetering = false; cancelAnimationFrame(animationFrameId); } else { if (audioContext && audioContext.state === 'suspended' && lastPlayedType === type) { audioContext.resume(); playbackStartTime = audioContext.currentTime; } else { play(startOffset, type); } isPlaying = true; if(type === 'mastered') startMeters(); updatePlayhead(); } updatePlayButtonStates(); }
        function drawWaveform(buffer) { const canvas = ui.waveformCanvas; const ctx = canvas.getContext('2d'); const width = ui.waveformContainer.clientWidth; const height = ui.waveformContainer.clientHeight; canvas.width = width; canvas.height = height; const data = buffer.getChannelData(0); const step = Math.ceil(data.length / width); const amp = height / 2; ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(160, 174, 192, 0.7)'; ctx.clearRect(0, 0, width, height); ctx.beginPath(); for (let i = 0; i < width; i++) { let min = 1.0, max = -1.0; for (let j = 0; j < step; j++) { const datum = data[(i * step) + j]; if (datum < min) min = datum; if (datum > max) max = datum; } ctx.moveTo(i, (1 + min) * amp); ctx.lineTo(i, (1 + max) * amp); } ctx.stroke(); }
        function formatTime(seconds) { const minutes = Math.floor(seconds / 60); const remainingSeconds = Math.floor(seconds % 60); return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`; }
        function updatePlayhead() { if (!isPlaying || !audioContext) { cancelAnimationFrame(animationFrameId); return; } const elapsed = audioContext.currentTime - playbackStartTime; const currentPlaybackTime = startOffset + elapsed; const progress = (currentPlaybackTime / audioBuffer.duration); if (progress >= 1) { ui.playhead.style.left = '100%'; ui.currentTime.textContent = formatTime(audioBuffer.duration); stopPlayback(); } else { ui.playhead.style.left = `${progress * 100}%`; ui.currentTime.textContent = formatTime(currentPlaybackTime); animationFrameId = requestAnimationFrame(updatePlayhead); } }
        
        // --- Render Helper ---
        async function getRenderedBuffer(buffer, settings) {
            const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const { finalNode } = applyMasteringChain(offlineCtx, source, settings);
            finalNode.connect(offlineCtx.destination);
            source.start(0);
            return await offlineCtx.startRendering();
        }

        async function exportMasteredFile() { 
            if (!audioBuffer || !masteringSettings) return; 
            ui.downloadMasteredBtn.disabled = true; 
            ui.downloadMasteredBtn.textContent = 'Exporting...'; 
            try { 
                const renderedBuffer = await getRenderedBuffer(audioBuffer, masteringSettings);
                const wavBlob = bufferToWave(renderedBuffer, 24); 
                const url = URL.createObjectURL(wavBlob); 
                const a = document.createElement('a'); 
                a.style.display = 'none'; 
                a.href = url; 
                const originalName = uploadedFile.name.split('.').slice(0, -1).join('.'); 
                a.download = `${originalName}Master.wav`; 
                document.body.appendChild(a); 
                a.click(); 
                window.URL.revokeObjectURL(url); 
                a.remove(); 
            } catch (e) { 
                console.error("Export failed:", e); 
                alert("Sorry, the export failed."); 
            } finally { 
                ui.downloadMasteredBtn.disabled = false; 
                ui.downloadMasteredBtn.textContent = 'Download Mastered'; 
            } 
        }

        function bufferToWave(audioBuffer, bitDepth = 24) { const numChannels = audioBuffer.numberOfChannels, sampleRate = audioBuffer.sampleRate, numFrames = audioBuffer.length, bytesPerSample = bitDepth / 8; const headerSize = 44, dataSize = numFrames * numChannels * bytesPerSample, fileSize = headerSize + dataSize; const buffer = new ArrayBuffer(fileSize), view = new DataView(buffer); let pos = 0; view.setUint8(pos++, 82); view.setUint8(pos++, 73); view.setUint8(pos++, 70); view.setUint8(pos++, 70); view.setUint32(pos, fileSize - 8, true); pos += 4; view.setUint8(pos++, 87); view.setUint8(pos++, 65); view.setUint8(pos++, 86); view.setUint8(pos++, 69); view.setUint8(pos++, 102); view.setUint8(pos++, 109); view.setUint8(pos++, 116); view.setUint8(pos++, 32); view.setUint32(pos, 16, true); pos += 4; view.setUint16(pos, 1, true); pos += 2; view.setUint16(pos, numChannels, true); pos += 2; view.setUint32(pos, sampleRate, true); pos += 4; view.setUint32(pos, sampleRate * numChannels * bytesPerSample, true); pos += 4; view.setUint16(pos, numChannels * bytesPerSample, true); pos += 2; view.setUint16(pos, bitDepth, true); pos += 2; view.setUint8(pos++, 100); view.setUint8(pos++, 97); view.setUint8(pos++, 116); view.setUint8(pos++, 97); view.setUint32(pos, dataSize, true); pos += 4; const channels = []; for (let i = 0; i < numChannels; i++) channels.push(audioBuffer.getChannelData(i)); const maxInt = 8388607; for (let i = 0; i < numFrames; i++) { for (let j = 0; j < numChannels; j++) { const floatSample = channels[j][i], clampedSample = Math.max(-1, Math.min(1, floatSample)); let intSample = Math.round(clampedSample * maxInt); view.setUint8(pos++, intSample & 255); view.setUint8(pos++, (intSample >> 8) & 255); view.setUint8(pos++, (intSample >> 16) & 255); } } return new Blob([view], { type: 'audio/wav' }); }
        
        // --- LUFS CALCULATION (EBU R128 Standard Compliance) ---
        async function calculateIntegratedLUFS(buffer) {
            const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;

            // ITU-R BS.1770-4 Coefficients
            const coefficients = {
                48000: {
                    stage1: { // High Shelf
                        feedforward: [1.53512485958697, -2.69169618940638, 1.19839281085285],
                        feedback: [1.0, -1.69065929318241, 0.73248077421585]
                    },
                    stage2: { // High Pass (RLB)
                        feedforward: [1.0, -2.0, 1.0],
                        feedback: [1.0, -1.99004745483398, 0.99007225036621]
                    }
                },
                44100: {
                    stage1: {
                        feedforward: [1.53069580543516, -2.65097999515473, 1.16698512767254],
                        feedback: [1.0, -1.66375013486698, 0.71045107281995]
                    },
                    stage2: {
                        feedforward: [1.0, -2.0, 1.0],
                        feedback: [1.0, -1.98916967588724, 0.98924026085366]
                    }
                }
            };

            const coeffs = coefficients[buffer.sampleRate];
            let filterStage1, filterStage2;

            if (coeffs) {
                // Use precise IIR Filters if sample rate matches standard
                filterStage1 = offlineCtx.createIIRFilter(coeffs.stage1.feedforward, coeffs.stage1.feedback);
                filterStage2 = offlineCtx.createIIRFilter(coeffs.stage2.feedforward, coeffs.stage2.feedback);
            } else {
                // Fallback for non-standard rates (approximate)
                console.warn("Using approximate K-Weighting for non-standard sample rate.");
                filterStage1 = offlineCtx.createBiquadFilter();
                filterStage1.type = 'highshelf';
                filterStage1.frequency.value = 1500;
                filterStage1.gain.value = 4.0;
                
                filterStage2 = offlineCtx.createBiquadFilter();
                filterStage2.type = 'highpass';
                filterStage2.frequency.value = 38;
            }

            source.connect(filterStage1);
            filterStage1.connect(filterStage2);
            filterStage2.connect(offlineCtx.destination);
            source.start();

            const kWeightedBuffer = await offlineCtx.startRendering();

            // 2. Calculate Loudness
            const sampleRate = kWeightedBuffer.sampleRate;
            const channels = [];
            for(let c = 0; c < kWeightedBuffer.numberOfChannels; c++) {
                channels.push(kWeightedBuffer.getChannelData(c));
            }

            // Gating block size: 400ms, 75% overlap (step: 100ms)
            const blockSize = Math.floor(0.4 * sampleRate);
            const stepSize = Math.floor(0.1 * sampleRate);
            const numBlocks = Math.floor((kWeightedBuffer.length - blockSize) / stepSize);
            
            if(numBlocks <= 0) return -99; // Audio too short

            const blockLoudnesses = [];

            // Calculate Mean Square for each block
            for (let i = 0; i < numBlocks; i++) {
                const start = i * stepSize;
                let sumSq = 0;
                // Sum squares of all channels for this block (BS.1770 Summation)
                for (let c = 0; c < channels.length; c++) {
                    for (let j = 0; j < blockSize; j++) {
                        const sample = channels[c][start + j];
                        sumSq += sample * sample;
                    }
                }
                
                const meanSquare = sumSq / blockSize;

                if (meanSquare > 1e-10) { // Avoid log(0)
                    const loudness = -0.691 + 10 * Math.log10(meanSquare);
                    blockLoudnesses.push(loudness);
                } else {
                    blockLoudnesses.push(-Infinity);
                }
            }

            // 3. Gating
            // Absolute Threshold: -70 LUFS
            const absoluteThreshold = -70;
            const aboveAbsolute = blockLoudnesses.filter(l => l > absoluteThreshold);

            if (aboveAbsolute.length === 0) return -70;

            // Calculate average of blocks above absolute threshold to find Relative Threshold
            // R128 summation: 10 * log10( mean( 10^(val/10) ) )
            let sumPower = 0;
            for(let l of aboveAbsolute) sumPower += Math.pow(10, l/10);
            const loudnessUnkagg = 10 * Math.log10(sumPower / aboveAbsolute.length);

            // Relative Threshold: loudnessUnkagg - 10 LU
            const relativeThreshold = loudnessUnkagg - 10;
            const aboveRelative = aboveAbsolute.filter(l => l > relativeThreshold);

            if (aboveRelative.length === 0) return -70;

            // Final Calculation
            sumPower = 0;
            for(let l of aboveRelative) sumPower += Math.pow(10, l/10);
            const finalLoudness = 10 * Math.log10(sumPower / aboveRelative.length);

            return finalLoudness;
        }

        // --- Check LUFS Handler ---
        ui.checkLufsBtn.addEventListener('click', async () => {
            if(!audioBuffer || !masteringSettings) return;
            
            const btnContent = ui.checkLufsBtn.innerHTML;
            ui.checkLufsBtn.innerHTML = `<svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Measuring...`;
            ui.checkLufsBtn.disabled = true;

            try {
                // Render current master
                const rendered = await getRenderedBuffer(audioBuffer, masteringSettings);
                // Calculate LUFS
                const lufs = await calculateIntegratedLUFS(rendered);
                
                // Update Modal
                ui.lufsValue.textContent = lufs.toFixed(1) + " LUFS";
                
                // Provide context message
                let msg = "";
                if (lufs > -9) msg = "Very loud (Club/EDM style). Might lack dynamic range.";
                else if (lufs > -12) msg = "Competitive loudness. Good for streaming (Spotify/Apple).";
                else if (lufs > -14) msg = "Dynamic and punchy. Ideal for streaming normalization.";
                else msg = "On the quiet side. Good for classical or jazz.";
                ui.lufsMsg.textContent = msg;

                // Show Modal
                ui.lufsModal.classList.remove('hidden');
            } catch (e) {
                console.error(e);
                alert("Could not calculate LUFS.");
            } finally {
                ui.checkLufsBtn.innerHTML = btnContent;
                ui.checkLufsBtn.disabled = false;
            }
        });

        ui.closeLufsModal.addEventListener('click', () => {
            ui.lufsModal.classList.add('hidden');
        });

        // --- Event Listeners & Main Logic ---
        ui.audioUpload.addEventListener('change', (event) => { const files = event.target.files; if (files.length > 0) { uploadedFile = files[0]; ui.fileNameEl.textContent = uploadedFile.name; ui.fileInfo.classList.remove('hidden'); ui.getInstructionsBtn.disabled = false; } });
        ui.getInstructionsBtn.addEventListener('click', async () => { if (!uploadedFile) return; ui.uploadSection.classList.add('hidden'); ui.resultSection.classList.remove('hidden'); ui.loadingSpinner.classList.remove('hidden'); ui.controlsWrapper.classList.add('hidden'); ui.resetBtn.classList.add('hidden'); ui.donationSection.classList.add('hidden'); try { ui.loadingText.textContent = 'Performing deep audio analysis...'; const analysis = await analyzeAudio(uploadedFile); ui.loadingText.textContent = 'Generating custom mastering chain...'; await new Promise(resolve => setTimeout(resolve, 500)); masteringSettings = generateMasteringSettings(analysis); if (masteringSettings) { populateUI(masteringSettings); setupAllListeners(); requestAnimationFrame(() => drawWaveform(audioBuffer)); ui.totalTime.textContent = formatTime(audioBuffer.duration); ui.controlsWrapper.classList.remove('hidden'); } else throw new Error("Could not generate mastering settings."); } catch (error) { console.error('Error during analysis or processing:', error); ui.loadingSpinner.innerHTML = `<div class="text-red-400 text-center"><p><strong>Oops! Something went wrong.</strong></p><p>${error.message}</p><p>Please try again with a different file.</p></div>`; } finally { ui.loadingSpinner.classList.add('hidden'); ui.loadingText.textContent = "Initializing..."; ui.resetBtn.classList.remove('hidden'); ui.donationSection.classList.remove('hidden'); } });
        ui.resetBtn.addEventListener('click', () => { stopPlayback(); if (audioContext && audioContext.state !== 'closed') audioContext.close(); ui.uploadSection.classList.remove('hidden'); ui.resultSection.classList.add('hidden'); ui.fileInfo.classList.add('hidden'); ui.fileNameEl.textContent = ''; ui.getInstructionsBtn.disabled = true; ui.audioUpload.value = ''; const canvas = ui.waveformCanvas; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); ui.playhead.style.left = '0%'; ui.currentTime.textContent = '0:00'; ui.totalTime.textContent = '0:00'; uploadedFile = null; audioBuffer = null; masteringSettings = null; isPlaying = false; lastPlayedType = null; isMetering = false; activeAudioNodes = null; startOffset = 0; updatePlayButtonStates(); });
        ui.waveformContainer.addEventListener('click', (e) => { if (!audioBuffer) return; const rect = ui.waveformContainer.getBoundingClientRect(); const x = e.clientX - rect.left; const progress = x / rect.width; const seekTime = progress * audioBuffer.duration; startOffset = seekTime; ui.currentTime.textContent = formatTime(seekTime); if(isPlaying) { stopPlayback(true); play(seekTime, lastPlayedType); } else { ui.playhead.style.left = `${progress * 100}%`; } });
        ui.previewOriginalBtn.addEventListener('click', () => togglePlayback('original'));
        ui.previewMasteredBtn.addEventListener('click', () => togglePlayback('mastered'));
        ui.downloadMasteredBtn.addEventListener('click', exportMasteredFile);
    </script>
</body>
</html>
